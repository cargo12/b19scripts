#!/bin/bash
# mwipe v4.5.0 last mod 2014/07/28
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2010, 2011, 2012, 2013, 2014 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------
# This will wipe out the beginning and end of every partition on all drives it
# can find, including a full wipe of the MBRs, and potentially a full zeroing of
# the drives as well.


#-------------------------------------------------------------------------------
# FUNCTIONS AND VARIABLES

zero=${0##*/}  # Appname
version=$(sed '2q;d' $0)  # Version from line 2

# getopt options
shortOpts="ynbrstfRxd:P:S:"
longOpts="bypass,dryrun,background,reboot,shutdown,chvt,full,random,extra,dev:,prefix:,suffix:"

# Colors
reset='\033[0;0m'
bold='\033[1;1m'
rbold="$reset$bold"
red='\033[0;31m'
green='\033[0;32m'
orange='\033[0;33m'
blue='\033[0;34m'
purple='\033[0;35m'
cyan='\033[0;36m'
lgrey='\033[0;37m'
RED='\033[1;31m'
GREEN='\033[1;32m'
ORANGE='\033[1;33m'
BLUE='\033[1;34m'
PURPLE='\033[1;35m'
CYAN='\033[1;36m'


show_usage() {
  echo "Usage: $zero [-y] [-n] [-b] [-r|-s] [-t] [ -f [-R] ] [-x] [-d DEV[,...]]
        or:  $zero [OPTIONS] [-P HOST_PREFIX] [-S HOST_SUFFIX] SSH_HOST...
        or:  $zero [-h|--help]"
}


show_help() {
  show_usage
  echo "
Wipe out all traces of partitions on specified block devices or if '-d' is 
ommitted, then do the same on all auto-detected block devices.

Host-selection options:"
  echo "
 -P, --prefix=PREFIX❚where PREFIX is text to be prepended to SSH_HOST
 -S, --suffix=SUFFIX❚where SUFFIX is text to be appended to SSH_HOST" |
column -s❚ -t

  echo "
Other options:"

  echo "
 -y, --bypass❚bypass warning prompts
 -n, --dryrun❚do everything except the actual commands
 -b, --background❚use ssh -n and bash job control to background each
                 ❚SSH process used for remote wiping (semi-parallelization)
                 ❚note: --background automatically triggers --chvt & --bypass
 -r, --reboot❚execute reboot after wipe complete
 -s, --shutdown❚execute halt after wipe complete
 -t, --chvt❚automatically change to tty9 and put output there
 -f, --full❚after wiping partitions, fully-wipe each drive
 -R, --random❚with --full only: use openssl PRNG instead of /dev/zero
 -x, --extra❚wipe operations destroy much bigger chunks of data (see below)
 -d, --dev DEV❚where DEV is the full path to a block device or a comma-
              ❚delimited list of the same
" | column -s❚ -t

  echo "
If run with no arguments, $zero will essentially look for any block devices
it can find and then wipe out between 32 and 64 KiB from the beginning and [up
to the] end of each detected partition (unless -x is used, in which case the
range is bumped up by a factor if 64, i.e.: to between 2 and 4 MiB). After that,
the partition table in the MBR will be wiped as well, virtually eliminating any
chance of easily recovering the data.

Note that the \"wiping\" $zero does entails writing random data generated by
OpenSSL's pseudo-random number generator.

When $zero finishes, it will simply exit, unless a '--reboot' or '--shutdown'
option is used (those options cause sysrq-triggered reboots or poweroffs).

Examples:
  $zero --bypass
  $zero --prefix=desktop 5 6 7 --suffix=.example.com
  $zero --bypass --reboot --dev=/dev/sda prod.b19.org web.b19.org
  $zero --bypass --reboot --dev=/dev/sda prod web --suffix=.b19.org
  
YOU USE THIS SOFTWARE AT YOUR OWN RISK

Version info: ${version:2}
See <github.com/ryran/b19scripts> to report bugs or suggestions"
  exit
}


pick_random_from_range() {
  rangeBegin=$1
  rangeEnd=$2
  echo $(( ( RANDOM % (rangeEnd - rangeBegin + 1) ) + rangeBegin ))
}


pick_random_amount_of_sectors() {
  # Need a random number where the product of it * sector size will be between 32 and 64 KiB
  rangeBegin=64                     # 32 KiB w/512b sectors
  rangeEnd=128                      # 64 KiB w/512b sectors
  if [[ $extraLong == y ]]; then    # If -x/--extra was used:
    rangeBegin=$((rangeBegin*64))   # 2 MiB w/512b sectors
    rangeEnd=$((rangeEnd*64))       # 4 MiB w/512b sectors
  fi
  if [[ $devSectorSize -ne 512 ]]; then
    rangeBegin=$((rangeBegin/8))
    rangeEnd=$((rangeEnd/8))
  fi
  pick_random_from_range $rangeBegin $rangeEnd
}


fullwipe_write_action() {
  if [[ $fullRandom = y ]]; then
    if command -v openssl >/dev/null; then
      openssl rand $devSizeBytes | dd of=$dev
    else
      dd if=/dev/urandom of=$dev
    fi
  else
    dd if=/dev/zero of=$dev
  fi
}


wipe_partition_start() {
  if command -v openssl >/dev/null; then
    openssl rand $((numRandSectors*devSectorSize)) | dd oflag=direct of=$dev bs=$devSectorSize seek=$partitionStart &>/dev/null
  else
    dd oflag=direct of=$dev bs=$devSectorSize seek=$partitionStart if=/dev/urandom count=$numRandSectors &>/dev/null
  fi
}


wipe_random_sector() {
  dd oflag=direct of=$dev bs=$devSectorSize seek=$1 if=/dev/urandom count=1 &>/dev/null
}


wipe_partition_end() {
  if command -v openssl >/dev/null; then
    openssl rand $((numRandSectors*devSectorSize)) | dd oflag=direct of=$dev bs=$devSectorSize seek=$((partitionEnd-numRandSectors)) &>/dev/null
  else
    dd oflag=direct of=$dev bs=$devSectorSize seek=$((partitionEnd-numRandSectors)) if=/dev/urandom count=$numRandSectors &>/dev/null
  fi
}


parse_positional_params() {
  unset bypass dryrun background post chvt slow fullWipe fullRandom extraLong deviceList hostPrefix hostSuffix remoteHosts
  # LOOP THROUGH OPTIONS UNTIL GET TO ARGUMENTS
  until [[ $1 == -- ]]; do 
    case $1 in
      -r|--reboot)      [[ -z $post ]] && post=reboot || {
                          echo "$zero: conflicting argument -- '$1'" >&2; show_usage; exit 1
                        }
    ;;
      -s|--shutdown)    [[ -z $post ]] && post=shutdown || {
                          echo "$zero: conflicting argument -- '$1'" >&2; show_usage; exit 1
                        }
    ;;
      -Y|--bypass)      bypass=y
    ;;  
      -n|--dryrun)      dryrun=y
    ;;  
      -b|--background)  background=y; chvt=y; bypass=y
    ;;  
      -w|--slow)        slow=y
    ;;
      -t|--chvt)        chvt=y
    ;;
      -f|--full)        fullWipe=y
    ;;
      -R|--random)      fullRandom=y
    ;;
      -x|--extra)       extraLong=y
    ;;
      -d|--dev)        deviceList=$(tr , ' ' <<<"$2"); shift
    ;;
      -P|--prefix)      hostPrefix=$2; shift
    ;;
      -S|--suffix)      hostSuffix=$2; shift
    ;;
    esac
    shift
  done
  shift
  # CHECK FOR MISSING SSH_HOST ARGS WHEN USING -P or -S or -b
  if [[ $# -eq 0 ]] && [[ -n $hostPrefix || -n $hostSuffix || -n $background ]]; then
    echo "$zero: missing SSH_HOST argument" >&2
    exit 1
  fi
  # ASSUME ANY ADDITIONAL ARGS ARE REMOTE SSH_HOSTS
  if [[ $# -gt 0 ]]; then
    remoteHosts=$@
  fi
}


#-------------------------------------------------------------------------------
# START PARSING POSITIONAL PARAMS

case ${1##*-} in
  help|\?|h) show_help
esac

getopt -Q --name=$zero -o $shortOpts -l $longOpts -- "$@" || { show_usage; exit 1; }

parse_positional_params $(getopt -u --name=$zero -o $shortOpts -l $longOpts -- "$@")


#-------------------------------------------------------------------------------
# PREPARE COMMAND SCRIPT
cmdScript=$(mktemp /dev/shm/$zero.XXXX)
trap "rm $cmdScript" EXIT

# GET VARIABLES & FUNCTIONS INTO COMMAND SCRIPT
cat >>$cmdScript <<EOF
  $(declare -p post bypass dryrun background slow chvt fullWipe fullRandom extraLong deviceList 2>/dev/null)
  $(declare -f pick_random_from_range pick_random_amount_of_sectors fullwipe_write_action wipe_partition_start wipe_random_sector wipe_partition_end)
EOF

# WRITE EVERYTHING ELSE INTO COMMAND SCRIPT
cat >>$cmdScript <<\EOF

  echo "Wipe executing on host: $(hostname)"
  
  # AUTODETECT DRIVES IF NOT SPECIFIED
  if [[ -z $deviceList ]]; then
    deviceList=$(awk '$4 ~ /^hd.$|^sd[[:alpha:]]+$|^md.$|^r+om.$|^r?flash.$|^rd\/c.{1,2}d.{1,2}$|^ida\/c.d.$|^i2o\/hd[[:alpha:]]+$|^amiraid\/ar.{1,2}$|cbd\/.$|^cciss\/c.d.{1,2}$|^iseries\/vd[[:alpha:]]+$|^ataraid\/d.{1,2}$|^emd\/.{1,2}$|^carmel\/.{1,2}$|^mmcblk.$|^ub.$|^xvd[[:alpha:]]+$|^vd[[:alpha:]]+$|^dasd[[:alpha:]]+$/ {printf " /dev/%s", $4}' /proc/partitions)
    autodetected=y
  fi

  # KITTEN-EATING WARNING
  if [[ $bypass != y ]]; then
    echo "CAUTION! DANGER!"
    echo "TAKE ADVANTAGE OF CTRL-C AT ANY TIME TO EXIT"
    echo
    if [[ $autodetected == y ]]; then
      echo "You have chosen to wipe the partitions on all detected drives"
    else
      echo "You have chosen to wipe the partitions on specified drives"
    fi
    echo "[$deviceList ]"
    echo
    echo "This is your only warning -- Are you sure this is what you want?"
    echo "Type uppercase YES to confirm"
    until [[ $a1 == YES ]]; do read -ep "> " a1; done
  fi

  # TO SWITCH OR NOT TO SWITCH
  if [[ $chvt == y ]]; then
    chvt 9
    exec 3>&1 1>/dev/tty9 2>&1
  fi

  # ITERATE THROUGH DEVICE LIST
  for dev in $deviceList ; do

    if partedOutput=$(parted -s $dev unit s print); then
      echo -e "\n================ ${dev} ================"
      echo -e "About to wipe out partitions!"
    else
      echo -e "\nError reading $dev -- skipping device"
      continue
    fi
    
    # GET DISK SIZE INFO
    numTotalSectors=$(grep '^Disk /dev/.*s$' <<<"$partedOutput" | sed -r 's,.*: ([0-9]+)s,\1,')
    # GET LOGICAL SECTOR SIZE
    devSectorSize=512  # default
    devSectorSize=$(grep '^Sector size' <<<"$partedOutput" | sed -r 's,.*: ([0-9]+)B/[0-9]+B,\1,')

    # KILL FIRST AND LAST XXXX KiB OF EACH PARTITION
    # To explicitly specify which part nums to wipe or the order to wipe them,
    # replace next line with e.g. 'for partition in 7 6 5 1 2 3 4 ; do'
    
    for partition in $(awk '/^[[:space:]]*[0-9]+/ {print $1}' <<<"$partedOutput" | sort -rn); do
        
        partitionStart=$(awk "\$1 == $partition {print \$2}" <<<"$partedOutput" | tr -d s)
        partitionEnd=$(awk "\$1 == $partition {print \$3}" <<<"$partedOutput" | tr -d s)
        partitionMiddle=$(( (partitionEnd - partitionStart) / 2 )) 
        
        partitionRandomSector=$(pick_random_from_range $((partitionMiddle - $(pick_random_amount_of_sectors) * 7))  $((partitionMiddle + $(pick_random_amount_of_sectors) * 5)) )
                   
        echo -e "\n${dev##*/}${partition}:"
        
        # WIPE PARTITION START
        numRandSectors=$(pick_random_amount_of_sectors)      
        echo "  Writing $((numRandSectors*devSectorSize/1024)) KiB random data to partition starting sector $partitionStart"
        [[ $dryrun == y ]] && echo "   (DRY-RUN; skipped writing)" || wipe_partition_start
        
        # WIPE PARTITION END
        numRandSectors=$(pick_random_amount_of_sectors)
        echo "  Writing $((numRandSectors*devSectorSize/1024)) KiB random data leading up to partition ending sector $partitionEnd"
        [[ $dryrun == y ]] && echo "   (DRY-RUN; skipped writing)" || wipe_partition_end
        
        ## WIPE RANDOM SECTORS IN PARTITION
        #echo -en "  Overwriting 200 random sectors from partition with random data...\n   "
        #[[ $dryrun == y ]] && echo -en "(DRY-RUN; skipping writing; sectors would have been as follows)\n   "
        #for c in {1..200}; do
        #  s=$(pick_random_from_range $partitionStart $partitionEnd)
        #  printf "$s "
        #  [[ $dryrun == y ]] || wipe_random_sector $s          
        #done
        #echo
        #
    done
    
    # WIPE MBR
    echo -e "\n${dev##*/} MBR/end:"
    numRandSectors=$(pick_random_amount_of_sectors)
    echo "  Writing $((numRandSectors*devSectorSize/1024)) KiB random data starting at device beginning"
    [[ $dryrun == y ]] && echo "   (DRY-RUN; skipped writing)" || 
      openssl rand $((numRandSectors*devSectorSize)) | dd oflag=direct of=$dev bs=$devSectorSize &>/dev/null
    
    # ALSO WIPE SECONDARY GPT HEADER
    numRandSectors=$(pick_random_amount_of_sectors)
    echo "  Writing $((numRandSectors*devSectorSize/1024)) KiB random data leading up to end of device"
    [[ $dryrun == y ]] && echo "   (DRY-RUN; skipped writing)" ||
      openssl rand $((numRandSectors*devSectorSize)) | dd oflag=direct of=$dev bs=$devSectorSize seek=$((numTotalSectors-numRandSectors)) count=$((numRandSectors+1)) &>/dev/null
    
  done

  # FULLWIPE CODE
  # I haven't gotten around to testing the following; it looks good to me, but it
  # might not work properly and could even ruin your life
  # If you want an explanation:
  # We're using dd to zero out each drive & bash job-control to parallelize
  if [[ $fullWipe = y ]]; then
    unset pids
    echo "Beginning to zero whole drive(s)..."
    for dev in $deviceList; do
      devSizeBytes=$(awk -v dev=$dev '$4==dev ${print $3/1024+1}' /proc/partitions)
      echo "Beginning whole-device-wipe operation on device $dev"
      [[ $dryrun == y ]] && echo " (DRY-RUN; skipped writing)" ||
          fullwipe_write_action &
      pids="$pids $!"
      sleep 5s
    done
    sleep 5s
    
  # Then, every two minutes we print out progress of each of these dd processes
  # Unfortunately, this part isn't magical enough to tell you which disk it is
  # TODO: Could easily do some fun with array variables to make it happen...
    for pid in $pids; do
      while kill -0 $pid; do kill -USR1 $pid; sleep 2m; done&
    done
    wait
  fi

  # PROLOGUE
  if [[ $background == y ]]; then
    exec 1>&3
    echo "Wipe finished on host: $(hostname) $(
      [[ $post == reboot ]] && echo ... REBOOTING
      [[ $post == shutdown ]] && echo ... HALTING
    )"
    exec 1>/dev/tty9
  fi
  echo -e "\nWipe finished on host: $(hostname)"

  if [[ $post == reboot ]]; then
    echo REBOOTING...
    for X in s u; do echo $X > /proc/sysrq-trigger; sleep 2; done
    reboot --force
  elif [[ $post == shutdown ]]; then
    echo HALTING...
    for X in s u; do echo $X > /proc/sysrq-trigger; sleep 2; done
    poweroff --force
  fi

EOF

#-------------------------------------------------------------------------------
# EXECUTE COMMAND SCRIPT

c_Sep=$CYAN ; c_Hostname=$GREEN ; c_Text=$orange

if [[ -n $remoteHosts ]]; then
  # If we have remote hosts, then let's run the command script on them
  for host in $remoteHosts; do
    if [[ $background == y ]]; then
      ssh -n -o ServerAliveCountMax=2 -o ServerAliveInterval=2 ${hostPrefix}${host}${hostSuffix} "$(<$cmdScript)" &
    else
      echo -e "\n${c_Sep}------------------------------------------------{${c_Hostname}${hostPrefix}${host}${hostSuffix}${c_Text}"
      ssh -o ServerAliveCountMax=2 -o ServerAliveInterval=2 ${hostPrefix}${host}${hostSuffix} "$(<$cmdScript)"
      printf "$reset"
    fi
  done
  wait
else
  # If no remote hosts, run locally
  bash $cmdScript
fi

