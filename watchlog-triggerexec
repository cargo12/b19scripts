#!/usr/bin/python
# -*- coding: utf-8 -*-
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2016 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------

from __future__ import print_function
from textwrap import dedent
import argparse
from subprocess import call, check_call, CalledProcessError
from tempfile import NamedTemporaryFile
from os import remove
from sys import exit

opts = None
prog = 'watchlog-triggerexec'
versionNumber = '0.2'
versionDate = '2016/05/24'
description = dedent("""
    Watch FILE until a line matching REGEX shows up, then execute COMMAND
    Requires inotifywait command from the inotify-tools package (EPEL)
    """)
epilog = dedent("""
    LICENSE / DISCLAIMER:
    
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
      
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
      General Public License <gnu.org/licenses/gpl.html> for more details.
    
    Version info: {0} v{1} last mod {2}
    For issues & questions, see: https://github.com/ryran/b19scripts/issues
    """.format(prog, versionNumber, versionDate))

def parse_cmdline():
    p = argparse.ArgumentParser(
        prog=prog,
        description=description,
        add_help=True,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    p.add_argument('-f', '--file', dest='watchFile', metavar='FILE', required=True, help="Specify [log] file to watch with 'tail -F FILE' (This file *must exist* and must be readable!)")
    p.add_argument('-r', '--regex', dest='watchRegex', metavar='REGEX', required=True, help="Specify line-based basic regular expression to watch for in FILE (Use quotes around REGEX; it will be passed to grep without validation so test it ahead of time)")
    p.add_argument('-c', '--cmd', dest='execCmd', metavar='COMMAND', required=True, help="Specify command(s) to execute when a match is triggered (Use quotes around COMMAND; it will be passed to shell without validation so test it ahead of time and be careful)")
    return p.parse_args()

def logger(message, pri="daemon.info", tag=prog):
    loggerCmd = ['logger', '-s', '-p', pri, '-t', tag, message]
    call(loggerCmd)

def bye():
    try:
        remove(opts.triggerFile)
    except:
        pass
    call(['pkill', '--pgroup', '0'])

def main():
    global opts
    opts = parse_cmdline()
    # Exit cleanly (early) if missing inotifywait
    try:
        check_call('command -v inotifywait >/dev/null', shell=True)
    except:
        print("Missing the inotifywait command (from the inotify-tools package)".format(prog))
        print("In RHEL, this can be installed from EPEL (https://fedoraproject.org/wiki/EPEL)")
        exit(1)
    # Create tempfile
    opts.triggerFile = NamedTemporaryFile(dir='/dev/shm').name
    # Execute tail|grep>>file in background subshell
    tailCmd = "(tail -Fn0 {0} | grep --line-buffered '{1}' >>{2}) &".format(opts.watchFile, opts.watchRegex, opts.triggerFile)
    call(tailCmd, shell=True)
    # Log start
    logger("file:'{0}', regex:'{1}' -- Initiating watch".format(opts.watchFile, opts.watchRegex))
    # Execute inotifywait, quiting if it fails for some reason
    try:
        check_call(['inotifywait', '-e', 'modify', opts.triggerFile])
    except CalledProcessError:
        logger("file:'{0}', regex:'{1}' -- inotifywait command returned error! Aborting!".format(opts.watchFile, opts.watchRegex, opts.execCmd), "daemon.err")
        bye()
    # If we get here, we hope inotifywait has cleanly exited due to match found
    logger("file:'{0}', regex:'{1}' -- MATCH FOUND! Executing cmd: {2}".format(opts.watchFile, opts.watchRegex, opts.execCmd), "daemon.warning")
    # Execute our user-requested command(s)
    call(opts.execCmd, shell=True)
    # Quit
    logger("file:'{0}', regex:'{1}' -- Exiting".format(opts.watchFile, opts.watchRegex, opts.execCmd))
    bye()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        logger("file:'{0}', regex:'{1}' -- User cancelled watch".format(opts.watchFile, opts.watchRegex), "daemon.warning")
        bye()