#!/bin/bash
# hhwchk v2.09 last mod 2011/11/26
# Latest version at <http://github.com/ryran/hhwchk>
# Copyright 2010, 2011 Ryan Sawhill <ryan@b19.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------
# Hops into systems via ssh to check out what they have in the way of hardware.
#
# When I started this script with the name host-hwcheck, I began with a simple
# purpose: I wanted to be able to quickly gather information about a handful of
# systems that I had been handed root access to -- specifically in a classroom
# environment where it was important that the students' systems be relatively
# uniform. Since my first days with linux I've been pretty handy with bash and
# so it never was much work to use for-loops along with ssh, but you know what
# they say about things that you have to do more than once, let alone every
# single week...
#
# So the initial goal was to display info on number of processors and their
# capabilities, plus amount of ram and disk space and I wanted to be able to
# do this on remote systems without requiring the script to reside on those
# systems as well.
# Right from the start I also wanted to be able to use number generation ('seq'
# or '{n..n}') for hostnames, along with some other configurable prefix like
# 'station' -- I don't know of a quick and elegant way to do this with bash
# trickery, so that was also part of it.
#
# Over the course of a month and a half, it evolved and vastly improved, with a
# small sacrifice in efficiency. This also prompted my first bit of self-study
# into awk, which I had only ever used for simply pulling out a column in text.
# I'm definitely still learning on that front -- you'll see me resort to piping
# almost-baked awk-output into sed or other commands because I haven't figured
# out all the wonders of this new and complicated (*ahem* .. to me) language.
# Hopefully this will continue to evolve in efficiency as my knowledge expands,
# but to move that process along quicker, send any ideas for ways to improve
# things to me at <ryan@b19.org>. I've been meaning to get into python as well
# actually, so if you're looking at this mess and thinking "WOW this would be so
# much better in XYZ LANGUAGE", hit me up and let me know.
#
# Notes:
# This script doesn't use absolute paths for cmd names; however there is some
# error-checking to account for the following commands being missing:
#   dmidecode, ethtool
# There is no error-checking for anything else, so standard coreutils and the
# util-linux-ng commands must be available via $PATH, plus the following:
#   gawk, xargs, sed, lspci
#-------------------------------------------------------------------------------

# I like color; please, sue me
reset='\E[0;0m'; blue='\E[0;34m'; cyan='\E[0;36m'; GREY='\E[01;30m'
purple='\E[0;35m'; red='\E[0;31m'; RED='\E[1;31m'
green='\E[0;32m'; GREEN='\E[1;32m'; orange='\E[0;33m'; ORANGE='\E[1;33m'

c_sep=$cyan ; c_h=$green ; c_text=$orange

zero=$(basename $0)
version=$(head -n2 $0 | grep -o "hhwchk v.*")

# GNU getopt short and long options:
sopts='P:S:LNbcdeghnrv'
lopts='prefix:,suffix:,localhost,nocolor,bios,cpu,disks,ethtool,graphics,hostname,net,ram,verbose'

USAGE()
{
echo "Usage: hhwchk [-Nbcdeghnr|-Nv] SSH_HOST...|--localhost"
echo "  or:  hhwchk -?|--help"
}

XHELP()
{
USAGE
echo "Use proc & standard tools to report hw info on localhost or ssh hosts

Host-selection options:"
echo "
 -P, --prefix=PREFIX@where PREFIX is text to be prepended to SSH_HOST
 -S, --suffix=SUFFIX@where SUFFIX is text to be appended to SSH_HOST
 -L, --localhost@operate on localhost instead of SSH_HOST via ssh" |
column -s@ -t

echo "
Display options:"
echo "
 -N, --nocolor@disable coloring of output
 -b, --bios@use dmidecode to query the bios for extra info
 -c, --cpu@show info on detected cpus
 -d, --disks@show info on block devices
 -e, --ethtool@use ethtool to show link speed of nics
 -g, --graphics@show info on vga adapters, via lspci
 -h, --hostname@show output of 'uname -rn' command
 -n, --net@show info on wifi/ethernet devices, via lspci
 -r, --ram@show info on ram
 -v, --verbose@show as much information as possible" |
column -s@ -t
echo "
Examples:
  hhwchk --localhost
  hhwchk -Lv
  hhwchk --cpu dev.b19.org prod.b19.org web.b19.org
  hhwchk -c dev prod web --suffix=.b19.org
  hhwchk --ram --bios station5 station6 station7
  hhwchk -rb --prefix station 5 6 7
  hhwchk -P root@station -S .example.com -v 5 6 7

Version info: $version
Report bugs or suggestions to <ryan@b19.org>
Or see <github.com/ryran/hhwchk> for bug tracker & latest version
Alternatively, run hhwchk with '--checkupdate'"
exit
}

UPDATE()
{
echo -e "${blue}Checking $0 against latest version at github.com/ryran/hhwchk ...${GREY}\n"
latest_version_file=$(mktemp /tmp/hhwchk_latest.XXX); trap "rm $latest_version_file" EXIT

# download latest version of hhwchk with wget or curl
if which wget &>/dev/null; then
	wget https://raw.github.com/ryran/hhwchk/master/hhwchk -O $latest_version_file
elif which curl &>/dev/null; then
	curl https://raw.github.com/ryran/hhwchk/master/hhwchk -o $latest_version_file ; echo
else
	echo -e "${RED}Need either wget or curl in \$PATH to perform the download!${reset}"
	exit 1
fi	

# save version string
latest_version=$(head -n2 $latest_version_file | grep -o "hhwchk v.*")

# compare currently running hhwchk with downloaded file
if ! diff $0 $latest_version_file >/dev/null; then
	echo -e "${blue}The version you are running reports as:\n\t${orange}$version${blue}\nThe version on github appears to be different and reports as:\n\t${ORANGE}$latest_version${blue}"
	echo -e "Press ${GREEN}enter${blue} to see the differences between them${reset}"
	read
	diff_file=$(mktemp /tmp/hhwchk.XXX.patch); trap "rm $diff_file" EXIT;
	# create a diff file
	diff -u $0 $latest_version_file > $diff_file
	# if it's installed, vim gives pretty colors
	which vim &>/dev/null && vim $diff_file || less $diff_file
	echo -e "${blue}If you are sure you know what you are doing, type ${GREEN}update${blue}\nto replace $0 with the latest version${GREEN}"
	read -p "> "
	if [[ $REPLY = update ]]; then
		echo -e "${blue}Backing up current version and replacing it with downloaded version ...${cyan}"
		cp -v $0 /tmp/hhwchk.orig
		cp -v $latest_version_file $0
		chmod +x $0
		echo -e "${reset}"
	else
		echo -e "${cyan}Not performing update${reset}"
	fi
else
	echo -e "${blue}You've got the same version as what's on github ($version)${reset}"
fi
exit
}

# check for help query
[ $# -eq 0 ] && { USAGE; echo "{$version}"; exit; }
case $1 in
  --help|-\?) XHELP
  ;;
  --checkupdate) UPDATE
esac

# check for bad switches
getopt -Q --name=hhwchk -o $sopts -l $lopts -- $* || { USAGE; exit 1; }

#-------------------------------------------------------------------------------
# parse command-line arguments
PARSE()
{
opts=n
unset pre suf localhost bios cpu disks ethtool graphics hostname net ram verbose
until [[ $1 = -- ]]; do
  case $1 in
    -P|--prefix)    pre=$2; shift 2
  ;;
    -S|--suffix)    suf=$2; shift 2
  ;;
    -L|--localhost) localhost=y; shift
  ;;
    -N|--nocolor)   nocolor=y; shift
  ;;
    -b|--bios)      bios=y; shift
                    opts=y
  ;;
    -c|--cpu)       cpu=y; shift
                    opts=y
  ;;
    -d|--disks)     disks=y; shift
                    opts=y
  ;;
    -e|--ethtool)   ethtool=y; shift
                    opts=y
  ;;
    -g|--graphics)  graphics=y; shift
                    opts=y
  ;;
    -h|--hostname)  hostname=y; shift
                    opts=y
  ;;
    -n|--net)       net=y; shift
                    opts=y
  ;;
    -r|--ram)       ram=y; shift
                    opts=y
  ;;
    -v|--verbose)   verbose=y; shift
                    opts=y
  esac
done
shift #(to get rid of the '--')
# check for missing HOST
if [[ $# -eq 0 && $localhost != y ]]; then
  echo -e "hhwchk: which hosts to check? (use '-L' for localhost)\n"
  USAGE
  exit 5
else
  hosts=$*
fi
}

PARSE $(getopt -u --name=hhwchk -o $sopts -l $lopts -- $*)

#-------------------------------------------------------------------------------
# time to set up which commands to run
cmdscript=$(mktemp /tmp/hhwchk.XXX)
trap "rm $cmdscript" EXIT

[[ $bios = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
if `which dmidecode` &>/dev/null && ! dmidecode -t memory|grep -q "table is broken"; then
  dmi=yes
  BIOS_phys_num_cpu="[bios: phys_cpus=$(dmidecode -s processor-family | wc -l), "
  BIOS_cpu_cores=$(dmidecode -t processor | awk '/Core Count/{totalcores+=$3;percpucores=$3}END{print "cores/cpu="percpucores", total_cores="totalcores"]"}')
  BIOS_model_cpu=$(echo "[`dmidecode -s processor-manufacturer|sort -u` `dmidecode -s processor-family|sort -u` @ `dmidecode -s processor-frequency|sort -u` <--says bios]")
  BIOS_ram=$(dmidecode -t memory|awk '/^[[:space:]]Size: [[:digit:]]/{numdims+=1;ram=$2;sumram+=ram}END{print "["numdims" DIMMs, "sumram" MB actual]"}')
else
  unset dmi
fi
EOF

[[ $hostname = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
                 echo -e "HOST: $(uname -nr)"
EOF

[[ $cpu = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
model_cpu=$(awk -F: '/model name/{print$2}' /proc/cpuinfo | sort -u | sed -e "s/(R)//g" -e "s/(TM)//g" -e "s/  */ /g")
num_cpu=$(grep processor /proc/cpuinfo | sort -u | wc -l)
num_cpu_phys=$(grep "physical id" /proc/cpuinfo | sort -u | wc -l)
[[ $num_cpu_phys -eq 0 ]] && num_cpu_phys=$num_cpu
if [[ $num_cpu_phys -ne $num_cpu ]]; then
  num_cores_per_cpu=$(grep cores /proc/cpuinfo|head -n1|awk {print\$4})
  [[ -n $num_cores_per_cpu ]] && cores=", ${num_cores_per_cpu} cores/ea"
fi
cpu_flags=$(egrep -o "pae|lm|vmx|svm" /proc/cpuinfo|sort -u|xargs echo|sed "s/ /,/g")
                 echo -e "CPU: ${num_cpu} logical cpus; flags=${cpu_flags}"
                 echo -e "  ${num_cpu_phys}${model_cpu}${cores}"
                 [[ -n $dmi ]] && echo -e "  ${BIOS_model_cpu}"
                 [[ -n $dmi ]] && echo -e "  ${BIOS_phys_num_cpu}${BIOS_cpu_cores}"

EOF

[[ $ram = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
sum_ram=$(free -m | awk /^Mem:/{print\$2})
                 echo -e "RAM: ${sum_ram} MB"
                 [[ -n $dmi ]] && echo -e "  ${BIOS_ram}"
EOF

[[ $disks = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
if [[ $UID -eq 0 ]]; then
  hdds=$(fdisk -l 2>/dev/null | awk '/^Disk.*[vsh]d.|^Disk.*xvd./ {NUMDISKS++; BYTES+=$5; DISK[$2]=$3" "$4} END {GBYTES=BYTES/1024/1024/1024; printf GBYTES" GB total, "NUMDISKS" disks\n"; for (i in DISK) print i,DISK[i]}' | sed -e "s@/dev/@  @" -e "s/,$//" -e "s/://")
                 echo -e "DISKS: ${hdds}"
fi
EOF

[[ $net = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
lspci_netdevs=$(lspci | awk -F: '/Net|Eth/{print$3}' | sed -e "s/ (rev.*//" -e "s/^/ /")
                 echo -e "NET:\n${lspci_netdevs}"
EOF

[[ $ethtool = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
if which ethtool &>/dev/null && [[ $UID -eq 0 ]]; then
  ethdevs=$(ifconfig | awk '/^peth|^eth|^em|^wlan|^usb/{print$1}' | grep -v :)
  ethtool_linkinfo=$(for i in $ethdevs;do echo -e "  $i\tlink=$(ethtool $i|awk '/Link detected:/{print$3}')$(spd=$(ethtool $i|awk '/Speed: 1/{print$2}');[[ -n $spd && $spd != Unknown! ]] && echo ", speed=$spd")";done)
                 echo -e "${ethtool_linkinfo}"
fi
EOF

[[ $graphics = y || $verbose = y ]] &&
cat >> $cmdscript <<\EOF
lspci_vga=$(lspci | awk -F: /VGA/{print\$3} | sed -e "s/ (rev.*//" -e "s/^/ /")
                 echo -e "VGA:\n${lspci_vga}"
EOF


cat >> $cmdscript <<\EOF
[[ $UID -ne 0 ]] && echo -e "\E[00;1m\E[41mSome information could not be displayed! Root-access required!\E[0m"
EOF

# what to do if no other display options are used
[[ $opts = n ]] &&
cat > $cmdscript <<\EOF
if `which dmidecode` &>/dev/null && ! dmidecode -t memory|grep -q "table is broken"; then
  BIOS_ram=$(dmidecode -t memory|awk '/Size: [[:digit:]]/{numdims+=1;ram=$2;sumram+=ram}END{print "("sumram" MB actual)"}')
fi

model_cpu=$(awk -F: '/model name/{print$2}' /proc/cpuinfo | sort -u | sed -e "s/(R)//g" -e "s/(TM)//g" -e "s/  */ /g")
num_cpu=$(grep processor /proc/cpuinfo | sort -u | wc -l)
num_cpu_phys=$(grep "physical id" /proc/cpuinfo | sort -u | wc -l)
[[ $num_cpu_phys -eq 0 ]] && num_cpu_phys=$num_cpu
if [[ $num_cpu_phys -ne $num_cpu ]]; then
  num_cores_per_cpu=$(grep cores /proc/cpuinfo|head -n1|awk {print\$4})
  [[ -n $num_cores_per_cpu ]] && cores=", ${num_cores_per_cpu} cores/ea"
fi
cpu_flags=$(egrep -o pae\|lm\|vmx\|svm /proc/cpuinfo|sort -u|xargs echo|sed s/\ /,/g)

sum_ram=$(free -m | awk /^Mem:/{print\$2})
hdds=$(fdisk -l 2>/dev/null| awk -F, '/^Disk.*[vsh]d.|^Disk.*xvd./{print$1}' | sed -e "s@/dev/@@" -e "s/Disk/DISK/")

                 echo "${num_cpu_phys}${model_cpu}${cores}"
                 echo "  (${num_cpu} logical cpus; flags=${cpu_flags})"
                 echo "RAM: ${sum_ram} MB ${BIOS_ram}"
                 echo "${hdds}"
[[ $UID -ne 0 ]] && echo -e "Some information could not be displayed! Root-access required!"
EOF

#-------------------------------------------------------------------------------
# finally, we run our script either on localhost or remotely over ssh

if [[ $nocolor = y ]]; then
  unset c_sep c_h c_text black
elif [[ $localhost = y && $opts != n ]]; then
  sed -i -e 's/HOST: /\\E[01;31m&\\E[00;31m/' -e 's/CPU: /\\E[01;33m&\\E[00;33m/' -e 's/RAM: /\\E[01;34m&\\E[00;34m/' -e 's/DISKS: /\\E[01;36m&\\E[00;36m/' -e 's/NET:/\\E[01;32m&\\E[00;32m/' -e 's/VGA:/\\E[01;35m&\\E[00;35m/' $cmdscript
  #cat $cmdscript
fi

if [[ $localhost = y ]]; then
  bash $cmdscript
else
  echo -e "${c_sep}  operating on: ${c_h}$pre{`echo $hosts|sed 's/ /,/g'`}$suf"
  for HOST in $hosts; do
    echo -e "${c_sep}------------------------------------------------{${c_h}$pre$HOST$suf${c_text}"
    ssh ${pre}${HOST}${suf} "$(cat $cmdscript)"
  done
fi
echo -en "$reset"
