#!/bin/bash
# valine v0.3.2a last mod 2014/07/25
# Latest version at <https://github.com/ryran/b19scripts>
# Copyright 2014 Ryan Sawhill <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#
#-------------------------------------------------------------------------------

# FIXME: Need to add cmdline-logic to accept lvm snapshot size 
# Also to autodetect if origin is a thin-volume so that we don't specify size at all
logvolSize="-L 3G"

# Program name
pzero=valine

# Get version from line #2
version=$(sed '2q;d' ${0})

# Colors
# FIXME: This is nonsense and simply due to poor planning (wasn't originally going to use colors so much)
BOLD='\033[1;1m'  ; B() { printf ${BOLD}; }
RESET='\033[0;0m' ; R() { printf ${RESET}; }
r='\033[0;31m'    ; r() { printf ${r}; }
g='\033[0;32m'    ; g() { printf ${g}; }
G='\033[1;32m'    ; G() { printf ${G}; }
b='\033[1;34m'
B='\033[1;34m'
o='\033[0;33m'
O='\033[1;33m'    ; O() { printf ${O}; }
p='\033[0;35m'
P='\033[1;35m'    ; P() { printf ${P}; }
c='\033[0;36m'    ; c() { printf ${c}; }
C='\033[1;36m'    ; C() { printf ${C}; }
Z() { printf ${b}; }

# Some global variables
skipPrompts=false
allDomains=false
startDomains=true
XML=
declare -i numTimesTrapTriggered=0
# GNU getopt short and long options
sOpts='ah'
lOpts='all,off,help'

Print() {
    echo -e "${BOLD}${@}${RESET}"
}

Prompt() {
    local REPLY
    if [[ ${skipPrompts} == true ]]; then
        echo "${@} [y/n] y"
    else
        read -p "${@} [y/n] "
        [[ ${REPLY} == y ]]
        return
    fi
}

wait_for_domid_turn_to_dash() {
    local -i count
    [[ ${parallelize} == false ]] && local printProgress="printf ."
    until [[ $(virsh domid ${1}) == - ]]; do
        count+=1
        sleep .5
        ${printProgress}
        case ${count} in
            8)   echo; echo -e "      ${Domain}: Waiting for domain to turn off" ;;
            30)  echo; echo -e "      ${Domain}: Domain has not yet turned off (still waiting)" ;;
            120) echo; echo -e "      ${Domain}: Domain has not yet turned off\n        Consider manual intervention on the domain's serial or physical console" ;;
            340) echo; echo -e "      ${Domain}: Domain still has not turned off\n        Manual intervention on the console is probably required\n        No more warnings will be printed" ;;
        esac
    done
}

wait_for_shutdown() {
    if [[ ${parallelize} == true ]]; then
        virsh shutdown ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Shutting down domain"
        virsh shutdown ${1} &>/dev/null
        printf "    Waiting for domain to shut down gracefully ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

wait_for_destroy() {
    if [[ ${parallelize} == true ]]; then
        virsh destroy ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Forcefully terminating domain"
        virsh destroy ${1} &>/dev/null
        printf "    Waiting for domain to terminate ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

show_usage() {
    echo -e "${BOLD}Usage: ${pzero}
       ${pzero} DOMAIN
       ${pzero} DOMAIN {list|new|revert}
       ${pzero} DOMAIN {revert|Delete} SNAPSHOT_NAME
       ${pzero} DOMAIN {start|shutdown|destroy|console}
       ${pzero} --all {new|revert|start|shutdown|destroy}${RESET}"
}

show_help() {
    show_usage
    echo -e "
Simple img-file snapshot-mgmt with intelligent BASH tab-completion

${BOLD}With no arguments:${RESET}
 ┐
 │${BOLD}${pzero}${RESET} by itself displays summary of all domains & their snapshots
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Snapshotting with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN [--off]${RESET}                                       (YES confirmation)
 │    if DOMAIN has zero snapshots, runs:  ${pzero} DOMAIN new
 │    if DOMAIN has any snapshots, runs:   ${pzero} DOMAIN revert
 │
 │${BOLD}${pzero} DOMAIN {list|l}${RESET}
 │    runs:
 │          virsh snapshot-list DOMAIN --parent
 │
 │${BOLD}${pzero} DOMAIN {new|n} [--off]${RESET}                               (NO confirmation)
 │    runs:
 │          virsh shutdown DOMAIN                             (and waits)
 │          virsh snapshot-create DOMAIN
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {revert|r} [--off]${RESET}                            (NO confirmation)
 │    runs:
 │          virsh destroy DOMAIN
 │          virsh snapshot-revert DOMAIN --current
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {revert|r} SNAPSHOT_NAME [--off]${RESET}              (NO confirmation)
 │    runs:
 │          virsh destroy DOMAIN
 │          virsh snapshot-revert DOMAIN SNAPSHOT_NAME
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {Delete|D} SNAPSHOT_NAME${RESET}                      (YES confirmation)
 │    runs:
 │          virsh snapshot-delete DOMAIN SNAPSHOT_NAME
 │
 │For more on managing snapshots:
 │    Virtualization Deployment & Administration Guide @ http://red.ht/1kwfbJs 
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Starting/stopping/accessing domains with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {start|s} | {shutdown|h} | {destroy|d} | {console|c}${RESET}
 │
 │start, shutdown, destroy, console commands are available as a convenience due
 │to virsh's lack of intelligent BASH tab-completion
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Managing ALL domains at once with ${pzero}:${RESET}
 ┐  
 │${BOLD}${pzero} --all [ {new|n} | {revert|r} | {start|s} | {shutdown|h} | {destroy|d} ]${RESET}
 │
 │Replace DOMAIN with '--all' (or '-a') to operate on all detected domains in
 │parallel (jobs are backgrounded, verbose output is lessened, and cancelling
 │requires double Ctrl-c)
 │Does not work with {console|c} or {Delete|D}
 │The --off switch is optional with {new|n} | {revert|r}
 │Omitting command (e.g., {new|n} is OK (with or without --off) and leads to
 │same behavior described for ${BOLD}${pzero} DOMAIN${RESET}
 └──────────────────────────────────────────────────────────────────────────────
 
${BOLD}Version info: ${version:2}${RESET}
  See <http://github.com/ryran/b19scripts> to report bugs or suggestions"
}

test_block_storage_is_lvm() {
    lvs "${primaryStorage}" &>/dev/null
}

test_file_storage_is_qcow2() {
    local imageType=$(qemu-img info "${primaryStorage}" | awk '/file format:/ {print $3}')
    [[ ${imageType} == qcow2 ]]
}

quietly_get_storage_source_type() {
    local sourceLine
    primaryStorage= storageType=
    sourceLine=$(virsh dumpxml --inactive ${Domain} | egrep "<source (file|dev)=" | head -1)
    primaryStorage=$(cut -d\' -f2 2>/dev/null <<<"${sourceLine}")
    if [[ -z ${primaryStorage} || ${primaryStorage} =~ \.iso ]]; then 
        storageType=unknown
    else
        if [[ ${sourceLine} =~ source.dev= ]]; then
            if test_block_storage_is_lvm; then
                storageType=lvm
                return
            fi
            storageType="raw block"
        else
            if test_file_storage_is_qcow2; then
                storageType=qcow2
                return
            fi
            storageType="raw image"
        fi
    fi
}

create_domain_config_file() {
    cat >${cfgFile} <<EOF
# valine config file for domain: ${Domain}
declare -Ag snapshots snapshotChildren
storageType=lvm
EOF
}

read_lvm_config() {
    cfgFile=/etc/${pzero}/${Domain}
    local -i i=0
    if . ${cfgFile} 2>/dev/null; then
        return
    else
        create_domain_config_file
        local LVM2_ORIGIN LVM2_LV_PATH
        eval $(lvs --nameprefixes --noheadings -o lv_path,origin ${primaryStorage})
        if [[ -n ${LVM2_ORIGIN} ]]; then
            # If has an origin, logvol is a snapshot
            originLV=${LVM2_LV_PATH%/*}/${LVM2_ORIGIN}
            snapshotLV=${LVM2_LV_PATH}
            echo "originLovol=${originLV}"     >>${cfgFile}
            echo "snapshots[snap0]=${snapshotLV}" >>${cfgFile}
            echo "snapshotChildren[_root]=snap0"  >>${cfgFile}
            i=1
        else
            originLV=${LVM2_LV_PATH}
            echo "originLovol=${originLV}"     >>${cfgFile}
            # Search for snapshots that logvol might have
            for snapshotLV in $(lvs --noheadings -o lv_path,origin | awk "\$2 == \"${LVM2_LV_PATH##*/}\" {print \$1}"); do
                echo "snapshots[snap${i}]=${snapshotLV}"       >>${cfgFile}
                echo "snapshotChildren[_root]+=\"snap${i} \""  >>${cfgFile}
                i+=1
            done
        fi
        . ${cfgFile}
        [[ ${i} -gt 0 ]]
    fi
}

_list_dom_state_and_snaps() {
    local s
    # Fun symbols to maybe use
    # ✔ ← ☀ ☚ ⚑ ◄ ◀ ◉
    __arrow() { printf "${G}←${RESET}" ; }
    quietly_get_storage_source_type
    case ${storageType} in
        unknown|raw*)
            line=" ${Domain} ❚${1}❚${storageType} ❚${primaryStorage} $(__arrow)"
            ;;
        lvm)
            read_lvm_config
            [[ ${primaryStorage} == ${originLogvol} ]] && originLogvol+=" $(__arrow)"
            line=" ${Domain} ❚${1}❚lvm ❚"
            line+="${originLogvol}"
            line+=$(
                    for s in ${snapshotChildren[_root]}; do
                        printf "\n❚❚❚  └─$(c)${s}"
                    done | 
                        sed \
                            -e "s,${primaryStorage##*-},$(C)&$(R) $(__arrow),"  \
                            -e "s,$,$(R),"
                  )
            ;;
        qcow2)
            line=" ${Domain} ❚${1}❚qcow2 ❚"
            line+="${primaryStorage}"
            if [[ -z $(virsh snapshot-list ${Domain} --name) ]]; then
                line+=" $(__arrow)"
            else
                line+=$(
                        if [[ -n $(virsh snapshot-list ${Domain} --name) ]]; then
                            printf "\n❚❚❚  └─$(c)"
                            virsh snapshot-list ${Domain} --tree |
                                sed \
                                    -e 's,|,│,g'           \
                                    -e "s,+- ,└─$(c),"     \
                                    -e '/^[ │]*$/d'        \
                                    -e '1!s,^,❚❚❚    ,'    \
                                    -e "s,$(virsh snapshot-current ${Domain} --name),$(C)&$(R) $(__arrow),"  \
                                    -e "s,$,$(R),"
                        fi
                      )
            fi
            ;;
    esac
    line+="\n❚❚❚\n"
    printf "${line}"
}

list_virts_and_snapshots() {
    {
        echo -e "❚❚❚\n DOMAIN❚⚡❚STORAGE❚SNAPSHOTS\n❚❚❚"
        for Domain in $(virsh list --name); do
            _list_dom_state_and_snaps "◉"
        done
        for Domain in $(virsh list --inactive --name); do
            _list_dom_state_and_snaps "◌"        
        done
        echo "❚❚❚"
    } |
        column -t -s "❚" -o " │ " |
            sed  \
                -e '1 s/│/┬/g' -e '1 s/ /─/g' -e "1 s/^/$(Z)/" -e "1 s/$/──────────────────────────────────────────$(R)/" \
                -e '3 s/│/┼/g' -e '3 s/ /─/g' -e "3 s/^/$(Z)/" -e "3 s/$/──────────────────────────────────────────$(R)/" \
                -e '$ s/│/┴/g' -e '$ s/ /─/g' -e "$ s/^/$(Z)/" -e "$ s/$/──────────────────────────────────────────$(R)/" \
                -e "s/│/$(Z)│$(R)/1" -e "s/│/$(Z)│$(R)/2" -e "s/│/$(Z)│$(R)/3" \
                -e "s/◉/$(g)&$(R)/" -e "s/◌/$(r)&$(R)/" \
                -r -e "2 s/ [⚡[:upper:]]*/$(O)&$(R)/g" \
                   -e "s/^ [[:graph:]]+/$(B)&$(R)/"  
}

get_next_available_lvm_snapshot_name() {
    local -i n=0
    until [[ -z ${snapshots[snap${n}]} ]]; do
        n+=1
    done
    echo snap${n}
}

get_domain_xml() {
    # Create a temp-file for the guest definition
    XML=$(mktemp -p /tmp ${pzero}.${Domain}.XXXX)
    trap "rm ${XML}" 0
    chcon -t virt_etc_rw_t ${XML}
    # Save guest definition to temp-file
    virsh dumpxml --inactive ${Domain} >${XML}
}

switch_domain_storage_to_device() {
    [[ -z ${XML} ]] && get_domain_xml
    sed -i "/source dev='${primaryStorage////\\/}'/s,${primaryStorage},${1}," ${XML}
    virsh undefine ${Domain}
    virsh define ${XML}
}

create_new_lvm_snapshot() {
    local newSnap=$(get_next_available_lvm_snapshot_name)
    echo "snapshots[${newSnap}]=${originLV##*/}-${newSnap}" >>${cfgFile}
    echo "snapshotChildren[_root]+=\"${newSnap} \""  >>${cfgFile}
    . ${cfgFile}
    lvcreate -s ${originLogvol} -n ${snapshots[${newSnap}]} ${logvolSize}
    echo ${snapshots[${newSnap}]}
}

new_snap() {
    Print "${Domain}: Must be shut down in order to create new snapshot"
    wait_for_shutdown ${Domain}
    quietly_get_storage_source_type
    case ${storageType} in
        lvm)
            read_lvm_config
            [[ ${primaryStorage} != ${originLogvol} ]] \
                && echo "info: with LVM, snapshots of snapshots are not supported"
            Print "${Domain}: Creating new lvm snapshot from origin ${originLogvol}"
            local newSnap=$(create_new_lvm_snapshot)
            Print "${Domain}: Configuring domain to use new snapshot logvol ${newSnap}"
            switch_domain_storage_to_device ${newSnap}
            ;;
        qcow2)
            Print "${Domain}: Creating new qcow2-based snapshot, tagging it as current"
            [[ ${parallelize} == false ]] && printf "  "
            virsh snapshot-create ${Domain}
            ;;
        *)
            Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
            exit 64
    esac
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

revert_snap() {
    if [[ -n ${1} ]]; then
        Print "${Domain}: Must be off to revert to old snapshot"
        wait_for_destroy ${Domain}
        Print "${Domain}: Reverting to snapshot ${1}"
        virsh snapshot-revert ${Domain} "${1}"
    else
        Print "${Domain}: Must be off to revert to snapshot"
        wait_for_destroy ${Domain}
        Print "${Domain}: Reverting to current snapshot"
        virsh snapshot-revert ${Domain} --current
    fi
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

delete_snap() {
    Print "About to remove snapshot ${1} from domain ${Domain}"
    Prompt "  Continue?" \
        && virsh snapshot-delete ${Domain} "${1}"
}

case_thru_args() {
    case ${1} in
        -bg)  parallelize=true ;;
          *)  parallelize=false ;;
    esac
    shift
    if [[ -z ${1} ]]; then
        if [[ -n $(virsh snapshot-list "${Domain}" --name) ]]; then
            Print "Default behavior would revert domain ${Domain} to its current snapshot"
            Prompt "  Continue?" \
                && revert_snap
        else
            Print "Default behavior would create a new snapshot of domain ${Domain}"
            Prompt "  Continue?" \
                && new_snap
        fi
    else
        case "${1}" in
            list|l)
                virsh snapshot-list "${Domain}" --parent
                ;;
            new|n)
                new_snap
                ;;
            revert|r)
                revert_snap "${2}"
                ;;
            Delete|D)
                delete_snap "${2}"
                ;;
            start|s)
                virsh start "${Domain}"
                ;;
            shutdown|h)
                virsh shutdown "${Domain}"
                ;;
            destroy|d)
                virsh destroy "${Domain}"
                ;;
            console|c)
                exec virsh console "${Domain}"
                ;;
            *)
                Print "Error: improper argument '${1}'"
                echo
                show_usage
                exit 64
        esac
    fi
}

cleanup_bg_jobs() {
    numTimesTrapTriggered+=1
    if [[ ${numTimesTrapTriggered} -eq 1 ]]; then
        echo
        Print "${pzero}: Background jobs still running"
        echo "  Hit Ctrl-c again to cancel all bg jobs & quit"
        sleep 1d
    else
        echo
        Print "${pzero}: Aborting background jobs"
        pkill --pgroup 0
    fi
}

sanity_check_args() {
    if [[ ${UID} != 0 ]]; then
        Print "Error: Need root privileges for 'virsh' or 'lvm' commands"
        exit 77
    elif [[ ${allDomains} == true ]]; then
        case "${1}" in
            console|c)
                Print "Error: 'console' command not compatible with --all"
                exit 64
                ;;
            Delete|D)
                Print "Error: 'delete' command not compatible with --all"
                exit 64
                ;;
            list|l)
                list_virts_and_snapshots
                exit
                ;;
            revert|r)
                if [[ -n ${2} ]]; then
                    Print "Error: Specifying snapshot name with 'revert' command not allowed with --all"
                    exit 64
                fi
                ;;
            new|n|start|s|shutdown|h|destroy|d)
                :
                ;;
            *)
                if [[ -n ${1} ]]; then
                    Print "Error: Improper argument '${1}'"
                    echo
                    show_usage
                    exit 64
                fi
        esac
    elif [[ -z ${1} ]]; then
        show_usage
        echo
        list_virts_and_snapshots
        exit        
    elif ! virsh list --all --name | grep -q "^${1}$"; then
        Print "Error: DOMAIN '${1}' not recognized"
        echo "Available domains:"
        virsh list --all --name | sed -e /^$/d -e 's/^/  • /' 
        exit 64
    elif [[ ${2} == revert || ${2} == r || ${2} == Delete || ${2} == D ]]; then
        if [[ -n ${3} ]]; then
            #if ! list_snapshots "${1}" "${3}"; then
            if ! virsh snapshot-list "${1}" --name | grep -q "^${3}"; then
                Print "Error: Invalid snapshot name '${3}'"
                echo "Available snapshots for domain ${1}:"
                virsh snapshot-list "${1}" --parent
                exit 64
            fi
        elif [[ ${2} == Delete || ${2} == D ]]; then
            Print "Error: Must specify snapshot name to delete"
            exit 64
        fi
    elif [[ -n ${3} ]]; then
        Print "Error: improper argument '${3}'"
        echo
        show_usage
        exit 64
    fi
}


list_snapshots() {
    get_primary_storage
    case ${storageType} in
        lvm)
            if test_domain_has_lvm_snapshots; then
            
                test_lvm_storage_is_snapshot
                
            else
                :
            fi
            ;;
        qcow2)
            virsh snapshot-list "${1}" --name | grep -q "^${2}"
    esac
}

get_primary_storage() {
    local chosenStorage=${1} sourceLine
    primaryStorage= storageType=
    sourceLine=$(virsh dumpxml --inactive ${Domain} | egrep "<source (file|dev)='${chosenStorage}(-snap)?" | head -1)
    if [[ -z ${sourceLine} && -n ${chosenStorage} ]]; then
        Print "Error: could not detect ${chosenStorage} as storage for ${Domain}"
        echo "Try letting ${pzero} auto-detect storage"
        exit 64
    elif [[ -z ${sourceLine} || ${sourceLine} =~ \.iso ]]; then 
        Print "Error: could not detect file or dev-based storage for ${Domain}"
        exit 64
    fi
    primaryStorage=$(cut -d\' -f2 <<<"${sourceLine}")
    if [[ ${sourceLine} =~ source.dev= ]]; then
        if ! test_block_storage_is_lvm ${primaryStorage}; then
            Print "Error: ${Domain} has non-LVM block storage"
            echo "For now, there's nothing ${pzero} can do"
            echo "(However, this will be implemented soon)"
            exit 64
        fi
        storageType=lvm
    else
        if ! test_file_storage_is_qcow2 ${primaryStorage}; then
            Print "Error: ${Domain} has non-qcow2 image storage"
            echo "For now, there's nothing ${pzero} can do"
            echo "(However, this will be implemented soon)"
            exit 64
        fi
        storageType=qcow2
    fi
}

main() {
    # Parse the cmdline
    until [[ ${1} == -- ]]; do
        case "${1}" in
            --all|-a)
                shift; allDomains=true ;;
            --off)
                shift; startDomains=false ;;
            --help|-h)
                shift; show_help; exit ;;
        esac
    done
    shift  # (to get rid of the '--')
    sanity_check_args "${@}"
    # Make shit happen
    if [[ ${allDomains} == true ]]; then
        # If run with --all/-a:
        if [[ -z ${1} ]]; then
            # If executed as: "$0 --all" (with or without --off) ...
            # Then: walk through interactive prompts in the foreground
            for Domain in $(virsh list --all --name); do
                case_thru_args -fg
            done
        else
            # If executed as: "$0 --all {new|revert|start|shutdown|destroy}" (with or without --off) ...
            # Then: kick off jobs in pseudo-parallel
            trap cleanup_bg_jobs 2
            for Domain in $(virsh list --all --name); do
                case_thru_args -bg "${@}" &
            done
            wait
            trap 2
        fi
    else
        Domain=${1}
        shift
        # If NOT run with --all/-a:
        case_thru_args -fg "${@}"
    fi
}

# Check for bad '-' or '--' options
getopt -Q --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}" || { show_usage; exit 64; }

# Main thread
main $(getopt -u --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}")
