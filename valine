#!/bin/bash
# valine v0.4.0 last mod 2014/07/31
# Latest version at <https://github.com/ryran/b19scripts>
# Copyright 2014 Ryan Sawhill <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#
#-------------------------------------------------------------------------------

# FIXME: Need to add cmdline-logic to accept lvm snapshot size 
# Also to autodetect if origin is a thin-volume so that we don't specify size at all
logvolSize="-L 3G"

# Program name
pzero=valine

# Get version from line #2
version=$(sed '2q;d' ${0})

# Colors
# FIXME: This is nonsense and simply due to poor planning (wasn't originally going to use colors so much)
BOLD='\033[1;1m'  ; B() { printf ${BOLD}; }
RESET='\033[0;0m' ; R() { printf ${RESET}; }
r='\033[0;31m'    ; r() { printf ${r}; }
g='\033[0;32m'    ; g() { printf ${g}; }
G='\033[1;32m'    ; G() { printf ${G}; }
b='\033[1;34m'
B='\033[1;34m'
o='\033[0;33m'
O='\033[1;33m'    ; O() { printf ${O}; }
p='\033[0;35m'
P='\033[1;35m'    ; P() { printf ${P}; }
c='\033[0;36m'    ; c() { printf ${c}; }
C='\033[1;36m'    ; C() { printf ${C}; }
Z() { printf ${b}; }

# Some global variables
skipPrompts=false
allDomains=false
startDomains=true
nonthinSnapshotLvDefaultSize=2G
XML=
declare -i numTimesTrapTriggered=0
# GNU getopt short and long options
sOpts='ahL:'
lOpts='all,off,help,size:'

Print() {
    echo -e "${BOLD}${@}${RESET}"
}

Prompt() {
    local REPLY
    if [[ ${skipPrompts} == true ]]; then
        echo "${@} [y/n] y"
    else
        read -p "${@} [y/n] "
        [[ ${REPLY} == y ]]
        return
    fi
}

wait_for_domid_turn_to_dash() {
    local -i count
    [[ ${parallelize} == false ]] && local printProgress="printf ."
    until [[ $(virsh domid ${1}) == - ]]; do
        count+=1
        sleep .5
        ${printProgress}
        case ${count} in
            8)   echo; echo -e "      ${Domain}: Waiting for domain to turn off" ;;
            30)  echo; echo -e "      ${Domain}: Domain has not yet turned off (still waiting)" ;;
            120) echo; echo -e "      ${Domain}: Domain has not yet turned off\n        Consider manual intervention on the domain's serial or physical console" ;;
            340) echo; echo -e "      ${Domain}: Domain still has not turned off\n        Manual intervention on the console is probably required\n        No more warnings will be printed" ;;
        esac
    done
}

wait_for_shutdown() {
    if [[ $(virsh domid ${1}) == - ]]; then
        echo "  Already off"
        return
    fi
    if [[ ${parallelize} == true ]]; then
        virsh shutdown ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Shutting down domain"
        virsh shutdown ${1} &>/dev/null
        printf "    Waiting for domain to shut down gracefully ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

wait_for_destroy() {
    if [[ $(virsh domid ${1}) == - ]]; then
        echo "  Already off"
        return
    fi
    if [[ ${parallelize} == true ]]; then
        virsh destroy ${1} &>/dev/null
        wait_for_domid_turn_to_dash ${1}
    else
        echo "  Forcefully terminating domain"
        virsh destroy ${1} &>/dev/null
        printf "    Waiting for domain to terminate ..."
        wait_for_domid_turn_to_dash ${1}
    fi
    echo
}

show_usage() {
    echo -e "${BOLD}Usage: ${pzero}
       ${pzero} DOMAIN
       ${pzero} DOMAIN new [SNAPSHOT_NAME] [--off] [--size LVSIZE]
       ${pzero} DOMAIN revert [SNAPSHOT_NAME] [--off]
       ${pzero} DOMAIN Delete SNAPSHOT_NAME
       ${pzero} DOMAIN {start|shutdown|destroy|console}
       ${pzero} --all {new|revert|start|shutdown|destroy}${RESET}"
}

show_help() {
    show_usage
    echo -e "
Easy qcow & LVM snapshot management wtih with intelligent BASH tab-completion

${BOLD}With no arguments:${RESET}
 ┐
 │${BOLD}${pzero}${RESET} by itself displays summary of all domains & their storage
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Snapshotting with ${pzero}:${RESET}
     ${r}FIXME: HELP PAGE NOT UPDATED FOR LVM YET${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN [--off]${RESET}                                       (YES confirmation)
 │    if DOMAIN has zero snapshots, runs:  ${pzero} DOMAIN new
 │    if DOMAIN has any snapshots, runs:   ${pzero} DOMAIN revert
 │
 │${BOLD}${pzero} DOMAIN {list|l}${RESET}
 │    runs:
 │          virsh snapshot-list DOMAIN --parent
 │
 │${BOLD}${pzero} DOMAIN {new|n} [--off] [--size LVSIZE]${RESET}               (NO confirmation)
 │    runs:
 │          virsh shutdown DOMAIN                             (and waits)
 │          virsh snapshot-create DOMAIN
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {revert|r} [--off]${RESET}                            (NO confirmation)
 │    runs:
 │          virsh destroy DOMAIN
 │          virsh snapshot-revert DOMAIN --current
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {revert|r} SNAPSHOT_NAME [--off]${RESET}              (NO confirmation)
 │    runs:
 │          virsh destroy DOMAIN
 │          virsh snapshot-revert DOMAIN SNAPSHOT_NAME
 │          virsh start DOMAIN                                (except w/ --off)
 │
 │${BOLD}${pzero} DOMAIN {Delete|D} SNAPSHOT_NAME${RESET}                      (YES confirmation)
 │    runs:
 │          virsh snapshot-delete DOMAIN SNAPSHOT_NAME
 │
 │For more on managing snapshots:
 │    Virtualization Deployment & Administration Guide @ http://red.ht/1kwfbJs 
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Starting/stopping/accessing domains with ${pzero}:${RESET}
 ┐
 │${BOLD}${pzero} DOMAIN {start|s} | {shutdown|h} | {destroy|d} | {console|c}${RESET}
 │
 │start, shutdown, destroy, console commands are available as a convenience due
 │to virsh's lack of intelligent BASH tab-completion
 └──────────────────────────────────────────────────────────────────────────────

${BOLD}Managing ALL domains at once with ${pzero}:${RESET}
 ┐  
 │${BOLD}${pzero} --all [ {new|n} | {revert|r} | {start|s} | {shutdown|h} | {destroy|d} ]${RESET}
 │
 │Replace DOMAIN with '--all' (or '-a') to operate on all detected domains in
 │parallel (jobs are backgrounded, verbose output is lessened, and cancelling
 │requires double Ctrl-c)
 │Does not work with {console|c} or {Delete|D}
 │The --off switch is optional with {new|n} | {revert|r}
 │Omitting command (e.g., {new|n} is OK (with or without --off) and leads to
 │same behavior described for ${BOLD}${pzero} DOMAIN${RESET}
 └──────────────────────────────────────────────────────────────────────────────
 
${BOLD}Version info: ${version:2}${RESET}
  See <http://github.com/ryran/b19scripts> to report bugs or suggestions"
}

set_primary_storage_source() {
    [[ -n ${1} ]] && local Domain=${1}
    primaryStorageSourceXmlLine=$(virsh dumpxml --inactive "${Domain}" | egrep "<source (file|dev)=" | head -1)
    primaryStorage=$(cut -d\' -f2 2>/dev/null <<<"${primaryStorageSourceXmlLine}")
}

test_primaryStorage_is_lvm() {
    local lvPath
    if lvPath=$(lvs --noheadings -o lv_path "${primaryStorage}" 2>/dev/null | tr -d ' '); then
        primaryStorage=${lvPath}
        return 0
    else
        return 1
    fi
}

create_domain_config_file() {
    cat >${cfgFile} <<EOF
# valine config file for domain: ${Domain}

unset lvPath isThinLv lvChildren
declare -Ag lvPath isThinLv lvChildren
storageType='lvm'

EOF
}

read_lvm_config() {
    [[ -n ${1} ]] && local Domain=${1}
    cfgFile=/etc/${pzero}/${Domain}
    if [[ -r ${cfgFile} ]]; then
        source ${cfgFile}
        return
    else
        local LVM2_VG_NAME LVM2_LV_NAME LVM2_LV_PATH LVM2_ORIGIN LVM2_POOL_LV
        eval $(lvs --nameprefixes --noheadings -o vg_name,lv_name,lv_path,origin,pool_lv ${primaryStorage})
        if [[ -n ${LVM2_ORIGIN} ]]; then
            # If has an origin, logvol is a snapshot
            Print "Error: ${Domain} has snapshot logvols that ${pzero} did not create"
            echo "Remove any snapshot logvols and configure ${Domain} to use original lv to continue"
            exit 64
        else
            create_domain_config_file
            echo -e "lvmVolgroup='${LVM2_VG_NAME}'\n"            >>${cfgFile}
            if [[ -n ${LVM2_POOL_LV} ]]; then
                echo "isThinLv[$LVM2_LV_NAME]='yes'"        >>${cfgFile}
            else
                echo "isThinLv[$LVM2_LV_NAME]='no'"         >>${cfgFile}
            fi
            echo -e "lvPath[$LVM2_LV_NAME]='${LVM2_LV_PATH}'\n"  >>${cfgFile}
        fi
        source ${cfgFile}
    fi
}

test_primaryStorage_is_qcow2() {
    local imageType=$(qemu-img info "${primaryStorage}" | awk '/file format:/ {print $3}')
    [[ ${imageType} == qcow2 ]]
}

set_primary_storage_source_type() {
    set_primary_storage_source "${1}"
    if [[ -z ${primaryStorage} || ${primaryStorage} =~ \.iso ]]; then 
        storageType=unknown
    else
        if [[ ${primaryStorageSourceXmlLine} =~ source.dev= ]]; then
            if test_primaryStorage_is_lvm; then
                storageType=lvm
                read_lvm_config "${1}"
            else
                storageType="raw block"
            fi
        else
            test_primaryStorage_is_qcow2 && storageType=qcow2 || storageType="raw image"
        fi
    fi
}

#~ get_primary_storage() {
    #~ local chosenStorage=${1}
    #~ set_primary_storage_source
    #~ if [[ -z ${primaryStorageSourceXmlLine} && -n ${chosenStorage} ]]; then
        #~ Print "Error: could not detect ${chosenStorage} as storage for ${Domain}"
        #~ echo "Try letting ${pzero} auto-detect storage"
        #~ exit 64
    #~ elif [[ -z ${primaryStorageSourceXmlLine} || ${primaryStorageSourceXmlLine} =~ \.iso ]]; then 
        #~ Print "Error: could not detect file or dev-based storage for ${Domain}"
        #~ exit 64
    #~ fi
    #~ if [[ ${primaryStorageSourceXmlLine} =~ source.dev= ]]; then
        #~ if ! test_block_storage_is_lvm ${primaryStorage}; then
            #~ Print "Error: ${Domain} has non-LVM block storage"
            #~ echo "For now, there's nothing ${pzero} can do"
            #~ echo "(However, this will be implemented soon)"
            #~ exit 64
        #~ fi
        #~ storageType=lvm
    #~ else
        #~ if ! test_file_storage_is_qcow2 ${primaryStorage}; then
            #~ Print "Error: ${Domain} has non-qcow2 image storage"
            #~ echo "For now, there's nothing ${pzero} can do"
            #~ echo "(However, this will be implemented soon)"
            #~ exit 64
        #~ fi
        #~ storageType=qcow2
    #~ fi
#~ }
#~ list_snapshots() {
    #~ get_primary_storage
    #~ case ${storageType} in
        #~ lvm)
            #~ if test_domain_has_lvm_snapshots; then
            #~ 
                #~ test_lvm_storage_is_snapshot
                #~ 
            #~ else
                #~ :
            #~ fi
            #~ ;;
        #~ qcow2)
            #~ virsh snapshot-list "${1}" --name | grep -q "^${2}"
    #~ esac
#~ }



lvm_print_children_of_parent() {
    local parent=${1} indent=${2} child pre printchild
    local -i count=0
    for child in ${lvChildren[$parent]}; do
        count+=1
    done
    for child in ${lvChildren[$parent]}; do
        count=$((count-1))
        pre= printchild=
        # FOR DISPLAY ON THIS CHILD'S LINE:
        if [[ ${count} -eq 0 ]]; then
            [[ ${indent} =~ │$ ]] && indent=${indent%│}
            pre="${indent}└"  # No other children
        else
            [[ ${indent} =~ │$ ]] && indent=${indent%│}
            pre="${indent}├"  # At least 1 more child
        fi
        
        # Print child
        if [[ ${child} == ${primaryStorage##*/} ]]; then
            printchild="${C}${child}${RESET} $(__arrow)"
        else
            printchild="${c}${child}${RESET}"
        fi
        printf "${pre}─${printchild}\n"
        
        # If child is also a parent:
        if grep -q "^${child}$" <<<"$( tr ' ' '\n' <<<${!lvChildren[@]} )"; then
            # What to do with indent for next loop:
            if [[ ${count} -eq 0 ]]; then
                # If our parent doesn't have another child:                
                indent="${indent} "  # FOR NEXT CHILD
            elif [[ ${count} -ge 1 ]]; then
                # If our parent has at least 1 more child: 
                indent="${indent}│"
            fi
            # Execute loop with current child as the parent
            lvm_print_children_of_parent ${child} "${indent}   "
        fi
    done
}

__arrow() { printf "${G}←${RESET}" ; }

_list_dom_state_and_snaps() {
    local s p
    # Fun symbols to maybe use
    # ✔ ← ☀ ☚ ⚑ ◄ ◀ ◉
    set_primary_storage_source_type
    case ${storageType} in
        unknown|raw*)
            line=" ${Domain} ❚${1}❚${storageType} ❚${primaryStorage} $(__arrow)"
            ;;
        lvm)
            #[[ ${primaryStorage} == ${originLogvol} ]] && originLogvol+=" $(__arrow)"
            line=" ${Domain} ❚${1}❚lvm ❚"
            line+=$(
                for p in ${!lvPath[@]}; do
                    if [[ ${primaryStorage} == ${lvPath[$p]} ]]; then
                        printf "${lvPath[$p]%/*}/${C}${lvPath[$p]##*/}${RESET} $(__arrow)\n"
                    else
                        printf "${lvPath[$p]%/*}/${c}${lvPath[$p]##*/}${RESET}\n"
                    fi
                    lvm_print_children_of_parent ${p} "  " 
                done | sed '1!s/^/❚❚❚/'
                  )
            ;;
        qcow2)
            line=" ${Domain} ❚${1}❚qcow2 ❚"
            line+="${primaryStorage}"
            if [[ -z $(virsh snapshot-list ${Domain} --name) ]]; then
                line+=" $(__arrow)"
            else
                line+=$(
                        if [[ -n $(virsh snapshot-list ${Domain} --name) ]]; then
                            printf "\n❚❚❚  └─$(c)"
                            virsh snapshot-list ${Domain} --tree |
                                sed -n -e "/| *$/ d;1h;1!H
                                    $ {x
                                    :a
                                        s/\(\n[ |]*\)+\([^[:cntrl:]]*\1[|+]\)/\1├\2/;t a
                                    :b
                                        s/\(\n[ |]*\)+/\1└/;t b
                                        s/|/│/g;s/- /─$(c)/g;p
                                    }" | 
                                        sed \
                                            -e '/^ *$/d'            \
                                            -e '1!s,^,❚❚❚    ,'    \
                                            -e "s,$(virsh snapshot-current ${Domain} --name),$(C)&$(R) $(__arrow),"  \
                                            -e "s,$,$(R),"
                                            
                                            #~ -e 's,|,│,g'           \
                                            #~ -e "s,+- ,└─$(c),"     \
                                            #~ -e '/^[ │]*$/d'        \
                        fi
                      )
            fi
            ;;
    esac
    line+="\n❚❚❚\n"
    printf "${line}"
}

list_virts_and_snapshots() {
    {
        echo -e "❚❚❚\n DOMAIN❚⚡❚STORAGE❚SNAPSHOTS\n❚❚❚"
        for Domain in $(virsh list --name); do
            _list_dom_state_and_snaps "◉"
        done
        for Domain in $(virsh list --inactive --name); do
            _list_dom_state_and_snaps "◌"        
        done
        echo "❚❚❚"
    } |
        column -t -s "❚" -o " │ " |
            sed  \
                -e '1 s/│/┬/g' -e '1 s/ /─/g' -e "1 s/^/$(Z)/" -e "1 s/$/──────────────────────────────────────────$(R)/" \
                -e '3 s/│/┼/g' -e '3 s/ /─/g' -e "3 s/^/$(Z)/" -e "3 s/$/──────────────────────────────────────────$(R)/" \
                -e '$ s/│/┴/g' -e '$ s/ /─/g' -e "$ s/^/$(Z)/" -e "$ s/$/──────────────────────────────────────────$(R)/" \
                -e "s/│/$(Z)│$(R)/1" -e "s/│/$(Z)│$(R)/2" -e "s/│/$(Z)│$(R)/3" \
                -e "s/◉/$(g)&$(R)/" -e "s/◌/$(r)&$(R)/" \
                -r -e "2 s/ [⚡[:upper:]]*/$(O)&$(R)/g" \
                   -e "s/^ [[:graph:]]+/$(B)&$(R)/"
    echo -e "\nKey:"
    echo -e "  • Each domain's current storage is marked with a green arrow: $(__arrow)"
    echo -e "  • Storage which is revertable & Deletable is displayed in ${c}cyan${RESET}\n"
}

get_next_available_lvm_snapshot_name() {
    local -i n=0
    while [[ ${lvChildren[${primaryStorage##*/}]} =~ ${primaryStorage##*/}-snap${n} ]]; do
        n+=1
    done
    echo ${primaryStorage##*/}-snap${n}
}

get_domain_xml() {
    # Create a temp-file for the guest definition
    XML=$(mktemp -p /tmp ${pzero}.${Domain}.XXXX)
    trap "rm ${XML}" EXIT
    chcon -t virt_etc_rw_t ${XML}
    # Save guest definition to temp-file
    virsh dumpxml --inactive ${Domain} >${XML}
}

switch_domain_storage_to() {
    if [[ ${storageType} != lvm ]]; then
        Print "Error: Switching domain storage is currently only supported with LVM"
        exit 64
    fi
    local currentStorage=${primaryStorage} newStorage=${1}
    [[ -z ${XML} ]] && get_domain_xml
    if ! egrep -q "source (dev|file)='${currentStorage}'" ${XML}; then
        currentStorage=${currentStorage##*/} currentStorage=/dev/mapper/${currentStorage//-/--}
        if ! egrep -q "source (dev|file)='${currentStorage}'" ${XML}; then
            Print "Error: Domain ${Domain} does not appear to have primary storage ('${primaryStorage}')"
            exit 64
        fi
    fi
    sed -i -r "/source (dev|file)='${currentStorage//\//\\/}'/s,${currentStorage},${newStorage}," ${XML}
    [[ ${parallelize} == false ]] && printf "  "
    virsh undefine ${Domain} | sed '/^$/d'
    [[ ${parallelize} == false ]] && printf "  "
    virsh define ${XML} | sed '/^$/d'
    primaryStorage=${newStorage}
}

exec_must_succeed() {
    local msg=${1}
    shift
    if ! ${@}; then
        Print "Error: ${msg}"
        echo "Aborting"
        exit 64
    fi
}

create_new_lvm_snapshot() {
    local snapshotSize snapshotName=${1} saveConfig=${2}
    if [[ ${isThinLv[${primaryStorage##*/}]} == yes ]]; then
        Print "${Domain}: Creating new thin LVM snapshot from thin origin ${primaryStorage#/dev/}"
        exec_must_succeed "Error: Problem creating snapshot ${lvmVolgroup}/${snapshotName}" \
                          lvcreate --setactivationskip n --snapshot --name ${snapshotName} ${primaryStorage}
        [[ -n ${saveConfig} ]] && echo "isThinLv[$snapshotName]='yes'" >>${cfgFile}
    else
        if [[ -n ${snapshotDesiredSize} ]]; then
            snapshotSize=${snapshotDesiredSize}
        else
            snapshotSize=${nonthinSnapshotLvDefaultSize}
        fi
        Print "${Domain}: Creating new ${snapshotSize} lvm snapshot from origin ${primaryStorage#/dev/}"
        exec_must_succeed "Error: Problem creating snapshot ${lvmVolgroup}/${snapshotName}" \
                          lvcreate --snapshot --name ${snapshotName} --size ${snapshotSize} ${primaryStorage}
        [[ -n ${saveConfig} ]] && echo "isThinLv[$snapshotName]='no'" >>${cfgFile}
    fi
}

new_snap() {
    local snapshotDesiredName=${1} snapshotName
    if [[ ${storageType} =~ raw|unknown ]]; then
        Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
        exit 64
    fi
    Print "${Domain}: Must be shut down in order to create new snapshot"
    wait_for_shutdown ${Domain}
    case ${storageType} in
        lvm)
            if [[ -n ${snapshotDesiredName} ]]; then
                snapshotName=${snapshotDesiredName}
            else
                snapshotName=$(get_next_available_lvm_snapshot_name)
            fi
            create_new_lvm_snapshot ${snapshotName} --update-cfg-file
            echo -e "lvChildren[${primaryStorage##*/}]+='${snapshotName} '\n" >>${cfgFile}
            source ${cfgFile}
            Print "${Domain}: Configuring domain to use new snapshot ${lvmVolgroup}/${snapshotName} as primary storage"
            switch_domain_storage_to /dev/${lvmVolgroup}/${snapshotName}
            ;;
        qcow2)
            Print "${Domain}: Creating new qcow2-based snapshot, tagging it as current"
            [[ ${parallelize} == false ]] && printf "  "
            virsh snapshot-create ${Domain}
            ;;
    esac
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

revert_snap() {
    local snapshotName=${1}
    if [[ ${storageType} == lvm ]]; then
        if [[ -z ${snapshotName} ]]; then
            Print "${Domain}: Must be off to recreate current snapshot logvol"
            wait_for_destroy ${Domain}
            create_new_lvm_snapshot ${primaryStorage##*/}
        else
            if [[ $(virsh domid ${Domain}) != - ]]; then
                Print "${Domain}: Must be off to change which logvol is in use"
                echo "  Do you want to shutdown gracefully or force destroy?" 
                echo "  (Choose shutdown if you plan to use the current storage again)"
                read -ep "  [s]hutdown or [d]estroy? > "
                case "${REPLY}" in
                    s|S|shutdown)
                        wait_for_shutdown ${Domain}
                        ;;
                    d|D|destroy)
                        wait_for_destroy ${Domain}
                        ;;
                    *)
                        Print "Error: Improper choice"
                        exit
                esac
            fi
            Print "${Domain}: Configuring domain to use logvol ${lvmVolgroup}/${snapshotName} as primary storage"
            switch_domain_storage_to /dev/${lvmVolgroup}/${snapshotName}
            if [[ ${startDomains} == true ]]; then
                Print "${Domain}: Starting ..."
                [[ ${parallelize} == false ]] && printf "  "
                virsh start ${Domain}
            fi
            return
        fi
    elif [[ ${storageType} == qcow2 ]]; then
        if [[ -n ${snapshotName} ]]; then
            Print "${Domain}: Must be off to switch to another snapshot"
            wait_for_destroy ${Domain}
            Print "${Domain}: Switching to newly-reverted snapshot ${snapshotName}"
            virsh snapshot-revert ${Domain} "${snapshotName}"
        else
            Print "${Domain}: Must be off to revert changes to snapshot"
            wait_for_destroy ${Domain}
            Print "${Domain}: Reverting changes to current snapshot"
            virsh snapshot-revert ${Domain} --current
        fi
    else
        Print "${Domain}: Error: 'revert' command does not yet support storage type '${storageType}'"
        exit 64
    fi
    if [[ ${startDomains} == true ]]; then
        Print "${Domain}: Starting with pristine snapshot"
        [[ ${parallelize} == false ]] && printf "  "
        virsh start ${Domain}
    fi
}

delete_snap() {
    case ${storageType} in
        lvm)
            if [[ ${primaryStorage} == /dev/${lvmVolgroup}/${1} ]]; then
                Print "Error: Cannot delete current storage for domain ${Domain}"
                echo "You must switch to alternate storage first"
                exit
            fi
            Print "About to remove storage /dev/${lvmVolgroup}/${1} from domain ${Domain}"
            Prompt "  Continue?" || return
            lvremove -f /dev/${lvmVolgroup}/${1}
            remove_stale_lvm_storage_from_config ${1}
            ;;
        qcow2)
            if [[ $(virsh snapshot-current ${Domain} --name) == ${1} ]]; then
                :  # Should probably add logic to warn about deleting current snapshot
            fi
            Print "About to remove snapshot ${1} from domain ${Domain}"
            Prompt "  Continue?" || return
            virsh snapshot-delete ${Domain} "${1}"
            ;;
        *)
            Print "Error: ${pzero} does not yet manage ${Domain}'s storage type (${storageType})"
            exit 64
    esac
}

case_thru_args() {
    case ${1} in
        -bg)  parallelize=true ;;
          *)  parallelize=false ;;
    esac
    shift
    if [[ -z ${1} ]]; then
        if [[ -n $(virsh snapshot-list "${Domain}" --name) ]]; then
            Print "Default behavior would revert domain ${Domain} to its current snapshot"
            Prompt "  Continue?" \
                && revert_snap
        else
            Print "Default behavior would create a new snapshot of domain ${Domain}"
            Prompt "  Continue?" \
                && new_snap
        fi
    else
        case "${1}" in
            new|n|revert|r|Delete|D)  [[ ${allDomains} == true ]] && set_primary_storage_source_type
        esac
        case "${1}" in
            list|l)
                virsh snapshot-list "${Domain}" --parent
                ;;
            new|n)
                new_snap "${2}"
                ;;
            revert|r)
                revert_snap "${2}"
                ;;
            Delete|D)
                delete_snap "${2}"
                ;;
            start|s)
                virsh start "${Domain}"
                ;;
            shutdown|h)
                virsh shutdown "${Domain}"
                ;;
            destroy|d)
                virsh destroy "${Domain}"
                ;;
            console|c)
                exec virsh console "${Domain}"
                ;;
            *)
                Print "Error: improper argument '${1}'"
                echo
                show_usage
                exit 64
        esac
    fi
}

cleanup_bg_jobs() {
    numTimesTrapTriggered+=1
    if [[ ${numTimesTrapTriggered} -eq 1 ]]; then
        echo
        Print "${pzero}: Background jobs still running"
        echo "  Hit Ctrl-c again to cancel all bg jobs & quit"
        sleep 1d
    else
        echo
        Print "${pzero}: Aborting background jobs"
        pkill --pgroup 0
    fi
}

test_domain_storage_exists() {
    local storageName=${1}
    [[ -n ${2} ]] && local Domain=${2}
    case ${storageType} in
        lvm)
            [[ -e /dev/${lvmVolgroup}/${storageName} ]] && return
            ;;
        qcow2)
            virsh snapshot-list "${Domain}" --name | grep -q "^${storageName}$" && return
    esac
    return 1
}

remove_stale_lvm_storage_from_config() {
    [[ ${storageType} == lvm ]] || return
    local storageName=${1}
    [[ -n ${2} ]] && local Domain=${2}
    if [[ -n ${isThinLv[$storageName]} && ! -e /dev/${lvmVolgroup}/${storageName} ]]; then
        sed -i -e "/\[${storageName}\]/d" -e "/='${storageName} *'/d" ${cfgFile}
        echo "Notice: Removed non-existent device '/dev/${lvmVolgroup}/${storageName}' from domain config: ${cfgFile}"
        #~ source ${cfgFile}
    fi
}

sanity_check_args() {
    if [[ ${UID} != 0 ]]; then
        Print "Error: Need root privileges for 'virsh' and potentially 'lvm' commands"
        exit 77
    elif [[ -n ${snapshotDesiredSize} ]]; then
        case "${1}" in
            new|n)
                : ;;
            *)
                Print "Error: --size can only be used with 'new' command"
                exit 64
        esac
    elif [[ ${allDomains} == true ]]; then
        case "${1}" in
            console|c)
                Print "Error: 'console' command not compatible with --all"
                exit 64
                ;;
            Delete|D)
                Print "Error: 'delete' command not compatible with --all"
                exit 64
                ;;
            list|l)
                list_virts_and_snapshots
                exit
                ;;
            revert|r)
                if [[ -n ${2} ]]; then
                    Print "Error: Specifying snapshot name with 'revert' command not allowed with --all"
                    exit 64
                fi
                ;;
            new|n)
                if [[ -n ${2} ]]; then
                    Print "Error: Specifying snapshot name with 'new' command not allowed with --all"
                    exit 64
                fi
                ;;
            start|s|shutdown|h|destroy|d)
                :
                ;;
            *)
                if [[ -n ${1} ]]; then
                    Print "Error: Improper argument '${1}'"
                    echo
                    show_usage
                    exit 64
                fi
        esac
        return
    elif [[ -z ${1} ]]; then
        list_virts_and_snapshots
        exit        
    elif ! virsh list --all --name | grep -q "^${1}$"; then
        Print "Error: DOMAIN '${1}' not recognized"
        echo "Available domains:"
        virsh list --all --name | sed -e /^$/d -e 's/^/  • /' 
        exit 64
    elif [[ -z ${3} ]] && [[ ${2} == Delete || ${2} == D ]]; then
        Print "Error: Must specify snapshot name to delete"
        exit 64
    fi
    
    case "${2}" in
        list|l|new|n|revert|r|Delete|D|start|s|shutdown|h|destroy|d|console|c)
            : ;;
        *)
            Print "Error: Improper command '${2}'"
            echo
            show_usage
            exit 64
    esac
    
    [[ -n ${3} ]] && case "${2}" in
        revert|r|Delete|D|new|n)
            : ;;
        *)
            Print "Error: Improper argument '${3}'"
            echo
            show_usage
            exit 64
    esac

    set_primary_storage_source_type "${1}"
        
    case "${2}" in
        new|n)
            if [[ -n ${3} ]] && test_domain_storage_exists "${3}" "${1}"; then
                Print "Error: Cannot use desired new snapshot name '${3}' because it already exists"
                exit 64
            fi
            ;;
        revert|r|Delete|D)
            if [[ -n ${3} ]] && ! test_domain_storage_exists "${3}" "${1}"; then
                Print "Error: Invalid snapshot/storage name '${3}'"
                remove_stale_lvm_storage_from_config "${3}" "${1}"
                echo "Run ${pzero} with no args to see what's available for ${1}"
                exit 64
            fi
    esac
}

main() {
    # Parse the cmdline
    until [[ ${1} == -- ]]; do
        case "${1}" in
            --all|-a)
                shift; allDomains=true ;;
            --off)
                shift; startDomains=false ;;
            -h)
                shift; show_usage; echo -e "\nRun ${pzero} --help for full help page"; exit ;;
            --help)
                shift; show_help; exit ;;
            --size|-L)
                snapshotDesiredSize=${2}; shift 2 ;;
        esac
    done
    shift  # (to get rid of the '--')
    sanity_check_args "${@}"
    # Make shit happen
    if [[ ${allDomains} == true ]]; then
        # If run with --all/-a:
        if [[ -z ${1} ]]; then
            # If executed as: "$0 --all" (with or without --off) ...
            # Then: walk through interactive prompts in the foreground
            for Domain in $(virsh list --all --name); do
                case_thru_args -fg
            done
        else
            # If executed as: "$0 --all {new|revert|start|shutdown|destroy}" (with or without --off) ...
            # Then: kick off jobs in pseudo-parallel
            trap cleanup_bg_jobs 2
            for Domain in $(virsh list --all --name); do
                case_thru_args -bg "${@}" &
            done
            wait
            trap 2
        fi
    else
        Domain=${1}
        shift
        # If NOT run with --all/-a:
        case_thru_args -fg "${@}"
    fi
}

# Check for bad '-' or '--' options
getopt -Q --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}" || { show_usage; exit 64; }

# Main thread
main $(getopt -u --name=${pzero} -o ${sOpts} -l ${lOpts} -- "${@}")
