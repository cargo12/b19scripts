#!/bin/bash
# extsuperkill v0.0.1 last mod 2013/10/01
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2013 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------


pzero=${0##*/}  # Appname
version=$(sed '2q;d' $0)  # Version from line 2

show_help() {
  echo "Usage: $pzero [ -Y | --bypass ] [ -a | --all | DEVICE... ]
        or:  $pzero [ -h | --help ]
Quickly destroy the primary and backup superblocks of ext filesystems on DEVICE
With -a or --all: do the same to all auto-detected ext[234] filesystems
With -Y or --bypass: no warning or chance to abort will be given

YOU USE THIS SOFTWARE AT YOUR OWN RISK

Version info: ${version:2}
See <github.com/ryran/b19scripts> to report bugs or suggestions"
  exit
}

autodetect_all_ext_devs() {
  for n in 2 3 4; do
    blkid -t TYPE=ext$n -o device
  done
}

test_dev_contains_extfs() {
  local blkidOutput TYPE
  if blkidOutput=$(blkid -o export $1); then
    eval $blkidOutput
    echo "$1 contains $TYPE filesystem"
    if [[ ${TYPE%?} == ext ]] && dumpe2fs -h $1 &>/dev/null; then
      :
    else
      echo "Choose a device that contains an ext[234] filesystem"
      exit
    fi
  else
    echo "$1 does not contain a recognizable filesystem"
    exit
  fi
}

get_block_size() {
  dumpe2fs -h $1 2>/dev/null | awk '/Block size:/ {print $3}'
}

get_superblocks() {
  dumpe2fs $1 2>/dev/null | awk '/superblock/ {print gensub(/.* superblock at ([0-9]+), .*/, "\\1", 1)}' | tac
}

wipe_superblocks() {
  for block in $(get_superblocks $1); do
    printf "$block "
    dd if=/dev/urandom bs=$(get_block_size $1) count=1 oflag=direct seek=$block of=$1 &>/dev/null
  done
  echo
}

parse_positional_params() {
  unset doAutodetect bypassWarning
  until [[ $1 == -- ]]; do
    case $1 in
      -a|--all)     doAutodetect=y
    ;;
      -h|--help)    show_help
    ;;
      -Y|--bypass)  bypassWarning=y
    esac
    shift
  done
  shift
  deviceList=$@
}

# getopt options
shortOpts="ahY"
longOpts="all,help,bypass"

# Check for bad args
getopt -Q --name=$pzero -o $shortOpts -l $longOpts -- "$@" || show_help

# Parse args proper-like and set variables appropriately
parse_positional_params $(getopt -u --name=$pzero -o $shortOpts -l $longOpts -- "$@")

# Do autodetection if requested
if [[ $doAutodetect == y ]]; then
  deviceList=$(autodetect_all_ext_devs)
  if [[ -n $deviceList ]]; then
    echo "Auto-detected ext filesystems on devices:"
    fold -sw $(($(tput cols)-3)) <<<$deviceList | sed 's/^/  /'
  else
    echo "Unable to auto-detect any ext filesystems"
    exit 1
  fi

# Otherwise print about specified devices:
elif [[ -n $deviceList ]]; then
  echo "Devices specified on command-line:"
  fold -sw $(($(tput cols)-3)) <<<$deviceList | sed 's/^/  /'

# If no autodetect or no devices specified:
elif [[ -z $deviceList ]]; then
  echo "No devices specified; use -a to auto-detect all devices"
  exit 1
fi

echo

# Force prompt to continue
if [[ $bypassWarning != y ]]; then
  echo "CAUTION WARNING DANGER!!"
  echo "About to irrevocably damage the ext filesystems on the above devices"
  echo "This is your only warning"
  echo "Type uppercase YES to continue"
  until [[ $a1 == YES ]]; do read -ep "> " a1; done
  echo
fi

# Get UUID of root filesystem (if all systems had findmnt, this would be easier)
rootDevUUID=$(blkid -o export $(mount | grep -w / | cut -f1) | awk -F= '/UUID=/ {print $2}')  # Oldskool rhel5

# GOAL: If wiping rootfs dev requested, do it LAST
# So, basically we're reorganizing the $deviceList so that the rootfs dev (if specified) is last
for dev in $deviceList; do
  if blkid -t UUID=$rootDevUUID $dev &>/dev/null; then
    rootDevPath=$dev
  else
    dL+="$dev "
  fi
done
[[ -n $rootDevPath ]] && deviceList="$dL $rootDevPath"

# FINALLY
# Iterate over devices
for dev in $deviceList; do
  # Make sure device is ext
  test_dev_contains_extfs $dev
  echo     "  Block size detected as $(get_block_size $dev)b"
  echo -en "  Wiping primary and backup superblocks at block numbers...\n    "
  # Wipe superblocks, printing as it goes
  wipe_superblocks $dev
  echo -e  "  Wipe finished\n"
done

