#!/bin/bash
# extsuperkill v0.0.2 last mod 2013/10/01
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2013 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------


pzero=${0##*/}  # Appname
version=$(sed '2q;d' $0)  # Version from line 2

show_help() {
  echo "Usage: $pzero [-Y|--bypass] [-f|--fast] -a|--all|DEVICE...
Quickly destroy the primary and backup superblocks of ext filesystems

With -a or --all: blkid is used to detect and select all ext[234] filesystems.
Otherwise, devices must be specified manually.
Either way, the selected devices will be listed and a warning prompt will
require confirmation to continue with the wiping.
To bypass the warning prompt, use -Y or --bypass; in that case, no warning or
chance to review selected devices and abort will be given.

Root access will of course be required; dumpe2fs is used to detect the
superblock locations and dd is used to overwrite them with random data.

After wiping all superblocks on a device, each superblock will be tested with
dumpe2fs. This additional check can be skipped with the -f or --fast options.

YOU USE THIS SOFTWARE AT YOUR OWN RISK

Version info: ${version:2}
See <github.com/ryran/b19scripts> to report bugs or suggestions"
  exit
}

autodetect_all_ext_devs() {
  for n in 2 3 4; do
    blkid -t TYPE=ext$n -o device
  done
}

test_dev_contains_extfs() {
  local blkidOutput TYPE
  if blkidOutput=$(blkid -o export $1); then
    eval $blkidOutput
    echo "$1 contains $TYPE filesystem"
    if [[ ${TYPE%?} == ext ]] && dumpe2fs -h $1 &>/dev/null; then
      :
    else
      echo "Choose a device that contains an ext[234] filesystem"
      exit
    fi
  else
    echo "$1 does not contain a recognizable filesystem"
    exit
  fi
}

get_block_size() {
  dumpe2fs -h $1 2>/dev/null | awk '/Block size:/ {print $3; exit}'
}

get_superblocks() {
  dumpe2fs $1 2>/dev/null | awk '/superblock/ {print gensub(/.* superblock at ([0-9]+), .*/, "\\1", 1)}' | tac
}

wipe_superblocks() {
  superblockList=$(get_superblocks $1)
  printf "    "
  for block in $superblockList; do
    printf "$block "
    dd if=/dev/urandom bs=$blockSize count=1 oflag=direct seek=$block of=$1 &>/dev/null
  done
  echo
}

check_superblocks() {
  for block in $superblockList; do
    printf "    $block:\t"
    if dumpe2fs -o superblock=$block $1 &>/dev/null; then
       echo "✖  Superblock appears intact! Check manually: 'dumpe2fs -o superblock=$block $1'"
    else
       echo "✔  Invalid filesystem superblock"
    fi
  done
}

parse_positional_params() {
  unset doAutodetect bypassWarning skipSuperBlockCheck
  until [[ $1 == -- ]]; do
    case $1 in
      -a|--all)     doAutodetect=y
    ;;
      -h|--help)    show_help
    ;;
      -Y|--bypass)  bypassWarning=y
    ;;
      -f|--fast)    skipSuperBlockCheck=y
    esac
    shift
  done
  shift
  deviceList=$@
}

# getopt options
shortOpts="ahYf"
longOpts="all,help,bypass,fast"

# Check for bad args
getopt -Q --name=$pzero -o $shortOpts -l $longOpts -- "$@" || show_help

# Parse args proper-like and set variables appropriately
parse_positional_params $(getopt -u --name=$pzero -o $shortOpts -l $longOpts -- "$@")

# Do autodetection if requested
if [[ $doAutodetect == y ]]; then
  deviceList=$(autodetect_all_ext_devs)
  if [[ -n $deviceList ]]; then
    echo "Auto-detected ext filesystem(s) on the following device(s):"
    fold -sw $(($(tput cols)-3)) <<<$deviceList | sed 's/^/  /'
  else
    echo "Unable to auto-detect any ext filesystems"
    exit 1
  fi

# Otherwise print about specified devices:
elif [[ -n $deviceList ]]; then
  echo "Device(s) specified on command-line:"
  fold -sw $(($(tput cols)-3)) <<<$deviceList | sed 's/^/  /'

# If no autodetect or no devices specified:
elif [[ -z $deviceList ]]; then
  echo "No devices specified; use -a to auto-detect all devices or -h for help"
  exit 1
fi

echo

# Force prompt to continue
if [[ $bypassWarning != y ]]; then
  echo "CAUTION WARNING DANGER!!"
  echo "About to irrevocably damage filesystem(s) on the above-mentioned device(s)"
  echo "This is your only warning; Type uppercase YES to confirm and initiate wiping"
  read -ep "> "
  [[ $REPLY == YES ]] || { echo "Aborting"; exit; }
  echo
fi

# Get UUID of root filesystem (if all systems had findmnt, this would be easier)
rootDevUUID=$(blkid -o export $(mount | grep -w / | cut -f1) | awk -F= '/UUID=/ {print $2}')  # Oldskool rhel5

# GOAL: If wiping rootfs dev requested, do it LAST
# So, basically we're reorganizing the $deviceList so that the rootfs dev (if specified) is last
for dev in $deviceList; do
  if blkid -t UUID=$rootDevUUID $dev &>/dev/null; then
    rootDevPath=$dev
  else
    dL+="$dev "
  fi
done
[[ -n $rootDevPath ]] && deviceList="$dL $rootDevPath"

# FINALLY
# Iterate over devices
for dev in $deviceList; do
  # Make sure device is ext
  test_dev_contains_extfs $dev
  blockSize=$(get_block_size $dev)
  echo "  Block size detected as ${blockSize}b"
  echo "  Wiping primary and backup superblocks at block numbers..."
  # Wipe superblocks, printing as it goes
  wipe_superblocks $dev
  echo "  Wipe finished"
  if [[ $skipSuperBlockCheck != y ]]; then
    echo "  Confirming all superblocks wiped..."
    check_superblocks $dev
  fi
  echo
done

